\documentclass[12pt]{article}
\usepackage{framed}
\usepackage[margin=1in,top=0.5in]{geometry}
\usepackage{moreverb}
\usepackage{multirow}
\begin{document}
\setlength{\parindent}{0pt}

\begin{framed}
Sol Boucher and Evan Klei \hfill CSCI-453-01 \hfill 04/28/14 \\
\vspace{6pt} \\
\centerline{\textbf{\huge FabComp: Hardware specification}}
\end{framed}

\section{Register transfer language}
This is the sequence of hardware actions performed by each processing phase, address mode calculation, and instruction execution.

% BEGIN RTL
\subsection{Fetch phase}
\begin{verbatimtab}
IR <- Mem[PC] # the instruction word
PC <- PC + 1
\end{verbatimtab}

\subsection{Decode phase}
\begin{verbatimtab}
# Logic for op0
if IR(ami) = 00 then
	cntl[i] <- 10000
elif IR(ami) = 01 or 10 then
	Addr[i] <- Mem[PC]
	cntl[i] <- 10000 | i
	PC <- PC + 1
elif IR(ami) = 11 then
	MDR <- Mem[PC] # the R-type immediate word
	cntl[i] <- 10000 | i
	PC <- PC + 1
	if MDR(sam) = 000 then # register value
		cntl[i] <- MDR(reg0)
	elif MDR(sam) = 001 then # register indirect
		Addr[i] <- Reg[MDR(reg0)]
	elif MDR(sam) = 010 then # scaled
		Val[i] <- MDR
		MDR <- Mem[PC] # the S-type immediate
		PC <- PC + 1
		MDR <- MDR >> 8
		Addr[i] <- Reg[Val[i](reg1)] << MDR
		Addr[i] <- Addr[i] + Reg[Val[i](reg0)]
	elif MDR(sam) = 011 then # doubly scaled
                Val[i] <- MDR
                MDR <- Mem[PC]
                TMP <- MDR
                PC <- PC + 1
                MDR <- MDR >> 8
                Addr[i] <- Reg[Val[i](reg1)] << MDR
                Addr[i] <- Reg[Val[i](reg0)] + Addr[i]
                MDR <- Mem[Addr[i]]
                Addr[i] <- MDR
                MDR <- TMP & 0xff
                MDR <- Reg[Val[i](reg2)] << MDR
                Addr[i] <- MDR + Addr[i]
	elif MDR(sam) = 100 then # auto increment
		Val[i] <- MDR
		Addr[i] <- Reg[Val[i](reg0)]
		Reg[Val[i](reg0)] <- Reg[Val[i](reg0)] + 1
	elif MDR(sam) = 101 then # auto decrement
		Val[i] <- MDR
		Addr[i] <- Reg[Val[i](reg0)]
		Reg[Val[i](reg0)] <- Reg[Val[i](reg0)] - 1
	elif MDR(sam) = 110 then # scaled displacement
		Val[i] <- MDR
		MDR <- Mem[PC] # the S-type immediate
		PC <- PC + 1
		MDR <- MDR >> 8
		Addr[i] <- Reg[Val[i](reg0)] << MDR
		MDR <- Mem[PC] # the I-type immediate
		PC <- PC + 1
		Addr[i] <- MDR + Addr[i]
	elif MDR(sam) = 111 then # doubly scaled displacement
		Val[i] <- MDR
		MDR <- Mem[PC] # the S-type immediate
		PC <- PC + 1
		TMP <- MDR
		MDR <- MDR >> 8
		Addr[i] <- Reg[Val[i](reg0)] << MDR
		MDR <- Mem[PC] # the I-type immediate
		PC <- PC + 1
		Addr[i] <- MDR + Addr[i]
		MDR <- Mem[Addr[i]]
		Addr[i] <- MDR
		MDR <- TMP & 0xff
		MDR <- Reg[Val[i](reg1)] << MDR
		Addr[i] <- Addr[i] + MDR
if IR(ami) = 10 then # PC-relative
	Addr[i] <- PC + Addr[i]

# Logic for op1
if IR(imm)(1) = 1 then # immdiate
	Val[1] <- Mem[PC]
	cntl[1] <- 1001
	PC <- PC + 1
else
	# do the same as for op0

# Logic for op2 is the same as that for op1

# decode the opcode at micro level
\end{verbatimtab}
\subsection{Memory Load}
\begin{verbatimtab}
if cntl[1](4) == 1 then
    if cntl[1](2) == 1 then
        Val[1] <- Mem[Addr[1]]
        cntl[1](2) <- 0
if cntl[2](4) == 1 then
    if cntl[2](2) == 1 then
        Val[2] <- Mem[Addr[2]]
        cntl[2](2) <- 0
\end{verbatimtab}

\subsection{Execute}
\begin{verbatimtab}
# call function described by entry IR(opc) of an off-memory uJumpTable

halt:
# bail out
and:
    # call validator_one
    MDR <- op1 & op2
    # return
or:
    # call validator_one
    MDR <- op1 | op2
    # return
xor:
    # call validator_one
    MDR <- op1 ^ op2
    # return
lsft:
    # call validator_one
    MDR <- op1 << op2
    # return
nand:
    # call validator_one
    # call and
    cntl[1] <- 10011
    cntl[2] <- 10000
    # call not
    # return
nor:
    # call validator_one
    # call or
    cntl[1] <- 10011
    cntl[2] <- 10000
    # call not
    # return
xnor:
    # call validator_one
    # call xor
    cntl[1] <- 10011
    cntl[2] <- 10000
    # call not
    # return
rsft:
    # call validator_one
    MDR <- op1 >> op2
    # return
# logical goes here
# logical goes here
# logical goes here
rasft:
    # call validator_one
    MDR <- op1 >>> op2
    # return
# logical goes here
# logical goes here
# logical goes here
slt:
    # call validator_one
    # call sub
    if MDR(15) = 1
        MDR <- 1
    else
        MDR <- 0
    # return
sgt:
    # call validator_one
    MDR <- op2 - op1
    if MDR(15) = 1
        MDR <- 1
    else
        MDR <- 0
    # return
seq:
    # call validator_one
    # call sub
    if MDR = 0
        MDR <- 1
    else
        MDR <- 0
    # return
sne:
    # call validator_one
    # call seq
    cntl[1] <- 10011
    cntl[2] <- 10000
    # call not
    # return
sle:
    # call validator_one
    # call sgt
    cntl[1] <- 10011
    cntl[2] <- 10000
    # call not
    # return
sge:
    # call validator_one
    # call slt
    cntl[1] <- 10011
    cntl[2] <- 10000
    # call not
    # return
add:
    # call validator_one
    MDR <- op1 + op2
    # return
sub:
    # call validator_one
    MDR <- op1 - op2
    # return
# compbranch goes here
# compbranch goes here
# compbranch goes here
# compbranch goes here
# compbranch goes here
# compbranch goes here
# validator_three goes here
# validator_three goes here
siz:
    # call validator_four
    if op1 = 0
       MDR <- 1
    else
       MDR <- 0
    # return
snz:
    # call validator_four
    # call siz
    cntl[1] <- 10011 
    # call not
    # return
not:
    # call validator_four
    MDR <- !op1
    # return
neg:
    # call validator_four
    MDR <- 0 - op1
    # return
# simpbranch goes here
# simpbranch goes here
incr:
	# call validator_six
	MDR <- op0 + 1
	# return
decr:
	# call validator_six
	MDR <- op0 - 1
	# return
jmp:
    # call validator_seven
    PC <- op0
    cntl[0] <- 10011
    # return

jal:
    # call validator_seven
    Reg[15] <- PC    
    PC <- op0
    cntl[0] <- 10011
    # return
call:
	# call validator_seven
	# call jal
	Reg[14] <- Reg[14] - 1
	Mem[Reg[14]] <- Reg[15]
	# return
ret:
	# call validator_eight
	cntl[0] <- 01111
	# call jmp
	Reg[14] <- Reg[14] + 1
	# return
move:
    # call validator_nine
    MDR <- op1
    # return

logical: # handles land, lor, lxor, lnand, lnor, lxnor
	# call validator_one
	tmp <- cntl[2]
	cntl[2] <- 10000
	# call siz
	Val[1] <- MDR
	cntl[1] <- tmp
	cntl[2] <- 10000
	# call siz
	cntl[1] <- 10001
	cntl[2] <- 10011
	# call function described by entry IR(opc) - 4 of an off-memory uJumpTable
	# return

compbranch: # handles blt, bgt, beq, bne, ble, bge
	# call validator_two
	# call function described by entry IR(opc) - 8 of an off-memory uJumpTable
	cntl[2] <- 10000
	cntl[1] <- cntl[0]
	# call bnz
	# return

simpbranch: # handles biz, bnz
	# call validator_five
	# call function described by entry IR(opc) - 4 of an off-memory uJumpTable
	if MDR = 1 then
		PC <- op0
	cntl[0] <- 10011
	# return

validator_one:
	# Check for 2-3 ops
	if cntl[0] = 10000
		# bail out loudly
	if cntl[1] = 10000 then
		# bail out loudly
	if cntl[2] = 10000 then
		cntl[2] <- cntl[1]
		cntl[1] <- cntl[0]
	# return

validator_two:
	# Check for 3 ops, op0 is not a register
	if cntl[0] = 10000 then
		# bail out loudly
	if cntl[1] = 10000 then
		# bail out loudly
	if cntl[2] = 10000 then
		# bail out loudly
	if cntl[0](4) = 0 then
		# bail out loudly
	# return

validator_three:
	# Kill immediately
	# bail out loudly

validator_four:
	# Check for 1-2 ops, set cntl[1] if it was empty

validator_five:
	# Check for 2 ops, op0 is not a register
	if cntl[0] = 10000 then
		# bail out loudly
	if cntl[1] = 10000 then
		# bail out loudly
	if cntl[0](4) = 0 then
		# bail out loudly
	# return

validator_six:
	# Check for 1 op
	if cntl[0] = 10000 then
		# bail out loudly
	# return

validator_seven:
	# Check for 1 op, op0 is not a register
	if cntl[0] = 10000 then
		# bail out loudly
	if cntl[0](4) = 0 then
		# bail out loudly
	# return

validator_eight:
	# Check for 0 op
	# return

validator_nine:
	# Check for 2 ops
    if cntl[0] = 10000 then
        # bail out loudly
    if cntl[1] = 10000 then
        # bail out loudly
    # return
\end{verbatimtab}

\subsection{Writeback}
\begin{verbatimtab}
if cntl[0](4) = 0 then
   Reg[cntl[0](3..0)] <- MDR
elif cntl[0](4) = 1 then
   Mem[Addr[cntl[0](3..0)]] <- MDR
\end{verbatimtab}
% END RTL

\end{document}
