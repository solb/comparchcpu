\documentclass[12pt]{article}
\usepackage{framed}
\usepackage[margin=1in,top=0.5in]{geometry}
\usepackage{moreverb}
\usepackage{multirow}
\begin{document}
\setlength{\parindent}{0pt}

\begin{framed}
Sol Boucher and Evan Klei \hfill CSCI-453-01 \hfill 04/28/14 \\
\vspace{6pt} \\
\centerline{\textbf{\huge FabComp: Hardware specification}}
\end{framed}

\section{Register transfer language}
This is the sequence of hardware actions performed by each processing phase, address mode calculation, and instruction execution.

\subsection{Fetch phase}
\begin{verbatimtab}
IR <- Mem[PC] # the instruction word
PC <- PC + 1
\end{verbatimtab}

\subsection{Decode phase}
\begin{verbatimtab}
# logic for op0
if IR(ami) = 00 then
	cntl[i] <- 10000
elif IR(ami) = 01 or 10 then
	Addr[i] <- Mem[PC]
	cntl[i] <- 10000 | i
	PC <- PC + 1
elif IR(ami) = 11 then
	MDR <- Mem[PC] # the R-type immediate word
	cntl[i] <- 10000 | i
	PC <- PC + 1
	if MDR(sam) = 000 then # register value
		cntl[i] <- MDR(reg0)
	elif MDR(sam) = 001 then # register indirect
		Addr[i] <- Reg[MDR(reg0)]
	elif MDR(sam) = 010 then # scaled
		Val[i] <- MDR
		MDR <- Mem[PC] # the S-type immediate
		PC <- PC + 1
		MDR <- MDR >> 8
		Addr[i] <- Reg[Val[i](reg1)] << MDR
		Addr[i] <- Addr[i] + Reg[Val[i](reg0)]
	elif MDR(sam) = 011 then # doubly scaled
                Val[i] <- MDR
                MDR <- Mem[PC]
                TMP <- MDR
                PC <- PC + 1
                MDR <- MDR >> 8
                Addr[i] <- Reg[Val[i](reg1)] << MDR
                Addr[i] <- Reg[Val[i](reg0)] + Addr[i]
                MDR <- Mem[Addr[i]]
                Addr[i] <- MDR
                MDR <- TMP & 0xff
                MDR <- Reg[Val[i](reg2)] << MDR
                Addr[i] <- MDR + Addr[i]
	elif MDR(sam) = 100 then # auto increment
		Val[i] <- MDR
		Addr[i] <- Reg[Val[i](reg0)]
		Reg[Val[i](reg0)] <- Reg[Val[i](reg0)] + 1
	elif MDR(sam) = 101 then # auto decrement
		Val[i] <- MDR
		Addr[i] <- Reg[Val[i](reg0)]
		Reg[Val[i](reg0)] <- Reg[Val[i](reg0)] - 1
	elif MDR(sam) = 110 then # scaled displacement
		Val[i] <- MDR
		MDR <- Mem[PC] # the S-type immediate
		PC <- PC + 1
		MDR <- MDR >> 8
		Addr[i] <- Reg[Val[i](reg0)] << MDR
		MDR <- Mem[PC] # the I-type immediate
		PC <- PC + 1
		Addr[i] <- MDR + Addr[i]
	elif MDR(sam) = 111 then # doubly scaled displacement
		Val[i] <- MDR
		MDR <- Mem[PC] # the S-type immediate
		PC <- PC + 1
		TMP <- MDR
		MDR <- MDR >> 8
		Addr[i] <- Reg[Val[i](reg0)] << MDR
		MDR <- Mem[PC] # the I-type immediate
		PC <- PC + 1
		Addr[i] <- MDR + Addr[i]
		MDR <- Mem[Addr[i]]
		Addr[i] <- MDR
		MDR <- TMP & 0xff
		MDR <- Reg[Val[i](reg1)] << MDR
		Addr[i] <- Addr[i] + MDR
if IR(ami) = 10 then # PC-relative
	Addr[i] <- PC + Addr[i]

# logic for op1
if IR(imm)(1) = 1 then # immdiate
	Val[1] \get Mem[PC]
	cntl[1] \get 1001
	PC \get PC + 1
else
	# do the same as for op0

# logic for op2 is the same as that for op1

# decode the opcode at micro level
\end{verbatimtab}
\subsection{Memory Load}
\begin{verbatimtab}
if cntl[1][2] == 1 then
   Val[1] <- Mem[Addr[1]]
   cntl[1][2] <- 0

if cntl[2][2] == 1 then
   Val[2] <- Mem[Addr[2]]
   cntl[2][2] <- 0
\end{verbatimtab}
\subsection{Execute}
\begin{verbatimtab}
   #CODE FOR EACH FUNCTION
\end{verbatimtab}
\subsection{Store}
\begin{verbatimtab}
if cntl[0][4] == 0 then
   Reg[cntl[0][3..0]] <- MDR
elif cntl[0][4] == 1 then
   Mem[Addr[cntl[0][3..0]]] <- MDR
\end{verbatimtab}

\end{document}
