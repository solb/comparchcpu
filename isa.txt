instructions
------------
	alu
	===
	inv $reg
	inv mem
	inv $reg, $reg
	inv $reg, mem
	add $reg, $reg
	add $reg, %imm
	add $reg, mem
	add $reg, $reg, $reg
	add $reg, $reg, %imm
	add $reg, $reg, mem
	sub
	not $reg
	not mem
	and
	or
	xor
	nand
	nor
	xnor
	lshift $reg, $reg
	lshift $reg, %imm
	lshift $reg, mem
	lshift $reg, $reg, $reg
	lshift $reg, $reg, %imm
	lshift $reg, $reg, mem
	rshift
	rashift

	cmp
	===
	siz $reg
	siz mem
	snz
	seq $reg, $reg
	seq $reg, %imm
	seq $reg, mem
	seq $reg, $reg, $reg
	seq $reg, $reg, %imm
	seq $reg, $reg, mem
	sne
	slt
	sle
	sgt
	sge

	pc
	==
	jmp $reg
	jmp #garbage, %imm
	jmp mem
	jal
	call
	ret
	biz $reg, $reg
	biz $reg, %imm
	biz $reg, mem
	bnz
	beq $reg, $reg, $reg
	beq $reg, $reg, %imm
	beq $reg, $reg, mem
	bne
	blt
	ble
	bgt
	bge
	for $reg, $reg, %imm
	break #garbage, %imm
	end #garbage

registers
---------
	hidden
	======
	pc
	imm
	mem

	general
	=======
	a0-2 (3)	[0000-0010]
	v			[0011]
	s0-3 (4)	[0100-0111]
	t0-5 (6)	[1000-1101]
	sp			[1110]
	ra			[1111]

undeveloped thoughts
--------------------
	address modes
	=============
	16-bit address space (65536)
	immediate (16-bit)
	register (4-bit)
	displacement (?)

	conditionals and loops
	======================
	do we want ifs or switches?
	do we want whiles or dos?
	assembler should pass "for" the address of the corresponding end

	bit-diddling
	============
	3-bit instruction type
	5-bit opcode
	the rest is type-dependent

	instruction types
	=================
	$reg (10 instructions)
	mem (6 instructions)
	$reg, $reg (22 instructions)
	$reg, %imm (23 instructions)
	$reg, mem (21 instructions)
	$reg, $reg, $reg (24 instructions)
	$reg, $reg, %imm (26 instructions, including add and sub with a memory location)
	$reg, $reg, mem (32 instructions, less add and sub because they don't fit)
