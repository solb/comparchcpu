instructions
------------
	alu
	===
        inv  011001  
	   inv $reg
 	   inv mem
	   inv $reg, $reg
	   inv $reg, mem
	add  000000
           add $reg, $reg
	   add $reg, %imm
	   add $reg, mem
	   add $reg, $reg, $reg
	   add $reg, $reg, %imm
	   add $reg, $reg, mem
	sub  000001
	not  011010
           not $reg
	   not mem
	and  000010
	or   000011
	xor  000100
	nand 000101
	nor  000110
	xnor 000111
	lshift 001000
           lshift $reg, $reg
	   lshift $reg, %imm
	   lshift $reg, mem
	   lshift $reg, $reg, $reg
 	   lshift $reg, $reg, %imm
	   lshift $reg, $reg, mem
	rshift 001001
	rashift 001010

	cmp
	===
	siz 001110
           siz $reg
	   siz mem
	snz 001111
    seq 001000
	   seq $reg, $reg
	   seq $reg, %imm
	   seq $reg, mem
	   seq $reg, $reg, $reg
	   seq $reg, $reg, %imm
	   seq $reg, $reg, mem
	sne 001001
	slt 001010
	sle 001011
	sgt 001100
	sge 001101

	pc
	==
    jmp 011011
	   jmp $reg
	   jmp #garbage, %imm
	   jmp mem
	jal 011100
	call 011101
	ret 011110
       biz 010110
	   biz $reg, $reg
	   biz $reg, %imm
	   biz $reg, mem-
	bnz 010111
	beq 010000
           beq $reg, $reg, $reg
	   beq $reg, $reg, %imm
	   beq $reg, $reg, mem
	bne 010001
	blt 010010
	ble 010011
	bgt 010100
	bge 010101
        for 011000
	   for $reg, $reg, %imm
	break 011111
           break %imm
	end 100000
Verification rules
------------------
0th: no validation      00000000
1st: 2-3 ops            00000001 - 00010111
2nd: 3 ops, op0 lval    00011000 - 00011101    
3rd: Fails validation   00011110 - 00011111
4th: 1-2 ops
5th: 2 ops, op0 lval
6th: 2 ops
7th: 0 ops
8th: op0 lval
lval is not immediate nor register

registers
---------
	hidden
	======
	pc
	imm
	mem

	general
	=======
	a0-2 (3)	[0000-0010]
	v			[0011]
	s0-3 (4)	[0100-0111]
	t0-5 (6)	[1000-1101]
	sp			[1110]
	ra			[1111]

Address Modes
-------------
nop 00
immediate address 01
PC relative 10
others 11
   Register 000
   Register Immediate 001
   Scaled 010
   Doubly Scaled 011
   Scaled Displacement 100
   Doubly Scaled Displacement 101
   Auto Increment 110
   Auto Decriment 111

Immediate Override
------------------
if value is 1 in first bit, override 2nd adm with immediate
if value is 1 in second bit, override 3rd adm with immediate

Instruction Format
------------------
00      000000 00  00  00  00 
over    opcode imm adm adm adm

	format for adm 11
	=================
	0    000 0000 0000 0000
	over adm reg1 reg2 reg3 
	reg 2 and 3 are based on secondary address control bits

	For Scaled types
	================
	00000000 0000000
	Imm1     Imm2
	determined by adm
	may be followed by 16bit immediate for scaled displacement

undeveloped thoughts
--------------------
	WE FORGOT TO INCLUDE A MOVE INSTRUCTION!

	conditionals and loops
	======================
	do we want whiles or dos?
        Switches?
	assembler should pass "for" the address of the corresponding end

data path
---------
	register representations
	========================
	addr block of 3 registers: stores the EAs computed by each relevant address mode
	val block of 3 registers: stores the values (from immediate or memory) of each operand

control path
------------
	register representations
	========================
	cntl block of 3 5-bit registers, with format:
		PURPOSE		MSB	TAIL
		register type	0	4-bit register identifier
		value type	1	val[0] through val[2]
		mdr		1	0011

	other hardware
	==============
	need uMem and a uPC for storing and navigating the ucode
	need a uStack and uSP to support procedure calls
	we'll want an additional uStack and uSP to keep track of for loops

	uprogram control flow
	=====================
	fetch:
		fetch control byte
		interpret address mode descriptors and load trailing immediate bytes
		read each secondary address mode descriptor and populate addr[0..2]
		compute effectice addresses into val[0..2]
		jump to decode
	decode:
		populate cntl[0..2]
		error check opcode/cntl compatibility
		jump to execute
	execute:
		call the appropriate uprocedure (essentially a switch on opcode)
			(each binary operation uses cntl[1..2] as operands and MDR as output)
			(each unary operation uses cntl[1] as operand and MDR as output)
		jump to store
	store:
		if MSB of cntl[0] is 0: write MDR to register block, address cntl[0](3 downto 0)
		if MSB of cntl[0] is 1: write MDR to memory, address val[cntl[0](3 downto 0)]
		jump to fetch
